# Reflector Oracle

Reflector oracle protocol is a combination of specialized smart contracts and peer-to-peer consensus of data provider
nodes maintained by trusted Stellar ecosystem organizations that serve as intermediaries between Stellar smart contracts
and external price feed data sources.

## How It Works

Oracle contracts are controlled by the multisig-protected consensus of reputable organizations. The smart contract admin
account always has all node public keys as co-signers with >50% multisig threshold, so more than half of the oracle
backing nodes have to agree on a transaction in order to store price feed data or modify the contract state.

Each node independently calculates values of quoted prices using deterministic idempotent algorithms to ensure
consistency, generates an update transaction, signs it with node's private key, and then shares it with other peers via
WebSocket protocol. If for some reason (ledger access delay, failing connection, version incompatibility, adversary
attack) any given node quotes a token/asset price different from other nodes, the transaction hash will not match the
hash generated by the majority and such transaction will be discarded by the ledger. This way Reflector utilizes Stellar
protocol underlying security to implement an uncomplicated yet robust consensus, which guarantees reliability, fault
tolerance and regular price feed updates.

For on-chain Stellar assets price feed data retrieval Reflector relies on a quorum of nodes connected to Stellar RPC
nodes. Each node independently fetches trades and state information from the Stellar ledger. Price feeds for generic
tokens get updated in a similar fashion, but nodes have to agree on the data pulled from external sources (CEX/DEX API,
banks, forex venues, price aggregators, stock exchanges, derivative platforms, etc.) All historical price feed data is
stored in the oracle contract and becomes immutable once it is written to the contract storage.

Reflector offers two data access models for Stellar on-chain oracles:

- **ReflectorPulse** oracles with a uniform 5 minutes update interval provide free access to published price feeds
- **ReflectorBeam** oracles allow flexible oracle provisioning and feature faster price updates in return for a small
  XRF invocation fee

Both contract implementation are compatible with
[SEP-40](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0040.md) ecosystem standard.
Check the standard for general info and public consumer interface documentation.

Cluster nodes report price feeds for all assets denominated in the `base` asset of the contract using the uniform
precision specified in `decimals()`. Prices get encoded as `i128` numbers where last N digits designate the fractional
part of the given oracle feed. So the actual price can be calculated as `price/10^decimals`.

An oracle feed receives regular updates with a pre-defined resolution. Timestamps from trades and other price sources
are normalized as `floor(unix_now()/resolution)*resolution` during the aggregation phase. It is important for consumer
contracts to check the `timestamp` field of the returned values against the current ledger timestamp to make sure that
reported quotes are not stale.

Other contracts interact with oracle contracts, retrieving data stored earlier by Reflector consensus.
Consumers can fetch historical ranges, use cross-price calculation, utilize TWAP averaging, or simply pull the most
recent token price depending on the use-case.

The following diagram outlines a general oracle data flow:

![Reflector flow diagram](https://reflector.network/images/reflector-diagram.svg "Reflector flow diagram")

## DAO

Reflector oracles network is governed by the decentralized autonomous organization ("DAO") consisting of organizations
and individuals that maintain Reflector server nodes, participating in the cluster consensus. XRF token is a utility
cryptocurrency token issued by the DAO.

Cluster operators receive tokens for participating in the consensus mechanism and providing their computational
resources to aggregate, validate, certify, and publish token price information. Correspondingly, accrued tokens
represent the equivalent of computational resources contributed by each party. These tokens can be used for Reflector
cluster governance voting, subscription services.

Each of DAO members have an equal voting power, and Reflector governance decisions are enacted by a simple majority of
votes (a ballot requirement of more than half of all members). A member of the DAO can be expelled from the organization
and the Reflector cluster only by the DAO decision. Inclusion of new members (only those who run a Reflector node and
participate in the consensus are eligible) follows the same rule.

Reflector DAO employs XRF tokens in key governance areas and as a fee token for paid services. XRF tokens spent in the
process are permanently taken out of circulation without the possibility to recover them in the future ("burned"),
representing spent computational resources equivalent.

## Usage

### ReflectorPulse Contract

Utilize this example to invoke oracles functions from your contract code.

```rust
/* contract.rs */
use crate::reflector::{ReflectorPulseClient, Asset as ReflectorAsset}; // Import Reflector interface
use soroban_sdk::{contract, contractimpl, Address, Env, String, Symbol};

#[contract]
pub struct MyAwesomeContract; // Of course, it's awesome, we know it!

#[contractimpl]
impl MyAwesomeContract {
    pub fn lets_rock(e: Env) {
        // Oracle contract address to use
        let oracle_address = Address::from_str(&e, "CAFJZQWSED6YAWZU3GWRTOCNPPCGBN32L7QV43XX5LZLFTK6JLN34DLN");
        // Create client for working with oracle
        let reflector_client = ReflectorPulseClient::new(&e, &oracle_address);
        // Ticker to lookup the price
        let ticker = ReflectorAsset::Other(Symbol::new(&e, &("BTC")));
        // Fetch the most recent price record for it
        let recent = reflector_client.lastprice(&ticker);
        // Check the result
        if recent.is_none() {
            //panic_with_error!(&e, "price not available");
        }
        // Retrieve the price itself
        let price = recent.unwrap().price;
        // Do not forget for price precision, get decimals from the oracle
        // (this value can be also hardcoded once the price feed has been
        // selected because decimals never change in live oracles)
        let price_decimals = reflector_client.decimals();

        // Let's check how much of quoted asset we can potentially purchase for $10
        let usd_balance = 10_0000000i128; // $10 with standard Stellar token precision
        let can_purchase = (usd_balance * 10i128.pow(price_decimals)) / price;

        // How many USD we'll need to buy 5 quoted asset tokens?
        let want_purchase = 5_0000000i128; // 5 tokens with standard Stellar token precision
        let need_usd = (want_purchase * price) / 10i128.pow(price_decimals);

        // Please note: check for potential overflows or use safe math when dealing with prices
    }
}
```

#### Pulse contract interface

Copy and save it in your smart contract project as "reflector_pulse.rs" file.
This is the oracle client interface definition.

```rust
/* reflector_pulse.rs */
use soroban_sdk::{contracttype, Address, Symbol, Vec};

// Oracle contract interface exported as ReflectorPulseClient
#[soroban_sdk::contractclient(name = "ReflectorPulseClient")]
pub trait Contract {
    // Base oracle symbol the price is reported in
    fn base() -> Asset;
    // All assets quoted by the contract
    fn assets() -> Vec<Asset>;
    // Number of decimal places used to represent price for all assets quoted by the oracle
    fn decimals() -> u32;
    // Quotes asset price in base asset at specific timestamp
    fn price(asset: Asset, timestamp: u64) -> Option<PriceData>;
    // Quotes the most recent price for an asset
    fn lastprice(asset: Asset) -> Option<PriceData>;
    // Quotes last N price records for the given asset
    fn prices(asset: Asset, records: u32) -> Option<Vec<PriceData>>;
    // Quotes the most recent cross price record for the pair of assets
    fn x_last_price(base_asset: Asset, quote_asset: Asset) -> Option<PriceData>;
    // Quotes the cross price for the pair of assets at specific timestamp
    fn x_price(base_asset: Asset, quote_asset: Asset, timestamp: u64) -> Option<PriceData>;
    // Quotes last N cross price records of for the pair of assets
    fn x_prices(base_asset: Asset, quote_asset: Asset, records: u32) -> Option<Vec<PriceData>>;
    // Quotes the time-weighted average price for the given asset over N recent records
    fn twap(asset: Asset, records: u32) -> Option<i128>;
    // Quotes the time-weighted average cross price for the given asset pair over N recent records
    fn x_twap(base_asset: Asset, quote_asset: Asset, records: u32) -> Option<i128>;
    // Price feed resolution (default tick period timeframe, in seconds - 5 minutes by default)
    fn resolution() -> u32;
    // Historical records retention period, in seconds (24 hours by default)
    fn history_retention_period() -> Option<u64>;
    // The most recent price update timestamp
    fn last_timestamp() -> u64;
    // Contract version
    fn version() -> u32;
    // Contract admin address
    fn admin() -> Option<Address>;
    // Extend asset TTL (time-to-live) in the contract storage
    fn extend_asset_ttl(sponsor: Address, asset: Asset);
    // Get asset expiration timestamp
    fn expires(asset: Asset) -> Option<u64>;
}

// Quoted asset definition
#[contracttype(export = false)]
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum Asset {
    Stellar(Address), // for Stellar Classic and Soroban assets
    Other(Symbol)     // for any external currencies/tokens/assets/symbols
}

// Price record definition
#[contracttype(export = false)]
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct PriceData {
    pub price: i128,   // asset price at given point in time
    pub timestamp: u64 // record timestamp
}

// Possible runtime errors
#[soroban_sdk::contracterror(export = false)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum Error {
    AlreadyInitialized = 0,
    Unauthorized = 1,
    AssetMissing = 2,
    AssetAlreadyExists = 3,
    InvalidConfigVersion = 4,
    InvalidTimestamp = 5,
    InvalidUpdateLength = 6,
    AssetLimitExceeded = 7,
    InvalidPricesUpdate = 8
}
```
### ReflectorBeam contract

Utilize this example to invoke oracle functions from your contract code.

```rust
/* contract.rs */
use crate::reflector::{ReflectorBeamClient, Asset as ReflectorAsset}; // Import Reflector Beam interface
use soroban_sdk::{contract, contractimpl, Address, Env, String, Symbol, symbol_short, auth::{ContractContext, InvokerContractAuthEntry, SubContractInvocation}};

#[contract]
pub struct MyAwesomeContract; // Of course, it's awesome, we know it!

#[contractimpl]
impl MyAwesomeContract {
    pub fn lets_rock(e: Env) {
        // Oracle contract address to use
        let oracle_address = Address::from_str(&e, "CAFJZQWSED6YAWZU3GWRTOCNPPCGBN32L7QV43XX5LZLFTK6JLN34DLN");
        // Create client for working with oracle
        let reflector_client = ReflectorBeamClient::new(&e, &oracle_address);
        // Authorize XRF fee charge for lastprice() invocation
        authorize_spend(&e, &reflector_client, &InvocationComplexity::Price, 1);
        // Ticker to lookup the price
        let ticker = ReflectorAsset::Other(Symbol::new(&e, &("BTC")));
        // Fetch the most recent price record for it
        let recent = reflector_client.lastprice(&e.current_contract_address(), &ticker);
        // Check the result
        if recent.is_none() {
            //panic_with_error!(&e, "price not available");
        }
        // Retrieve the price itself
        let price = recent.unwrap().price;
        // Do not forget for price precision, get decimals from the oracle
        // (this value can be also hardcoded once the price feed has been
        // selected because decimals never change in live oracles)
        let price_decimals = reflector_client.decimals();

        // Let's check how much of quoted asset we can potentially purchase for $10
        let usd_balance = 10_0000000i128; // $10 with standard Stellar token precision
        let can_purchase = (usd_balance * 10i128.pow(price_decimals)) / price;

        // How many USD we'll need to buy 5 quoted asset tokens?
        let want_purchase = 5_0000000i128; // 5 tokens with standard Stellar token precision
        let need_usd = (want_purchase * price) / 10i128.pow(price_decimals);

        // Please note: check for potential overflows or use safe math when dealing with prices
    }
}

// Authorization is required to spend XRF tokens that cover invocation cost
fn authorize_spend(e: &Env, reflector_client: &ReflectorBeamClient, complexity: &InvocationComplexity, periods: u32) {
    // How much will it cost
    let cost = reflector_client.estimate_cost(&complexity, &periods);
    // XRF token address on Mainnet
    let xrf = Address::from_str(&e, "CBLLEW7HD2RWATVSMLAGWM4G3WCHSHDJ25ALP4DI6LULV5TU35N2CIZA");
    // Build authorization request
    let invocation = InvokerContractAuthEntry::Contract(SubContractInvocation {
        context: ContractContext {
            contract: xrf, // Contract address
            fn_name: symbol_short!("burn"), // XRF tokens get burned after usage
            args: Vec::from_array(
                e,
                [
                    e.current_contract_address().to_val(), // Current contract authorizes spend
                    cost.into_val(&e), // Reflector invocation cost
                ],
            ),
        },
        sub_invocations: Vec::new(&e), // No subinvocations required
    });
    // Request authorization
    e.authorize_as_current_contract(Vec::from_array(e, [invocation]));
}
```

#### Beam contract interface

Copy and save it in your smart contract project as "reflector_beam.rs" file.
This is the oracle client interface definition.

```rust
/* reflector_beam.rs */
use soroban_sdk::{contracttype, Address, Symbol, Vec};

// Oracle contract interface exported as ReflectorBeamClient
#[soroban_sdk::contractclient(name = "ReflectorBeamClient")]
pub trait Contract {
    // Base oracle symbol the price is reported in
    fn base() -> Asset;
    // All assets quoted by the contract
    fn assets() -> Vec<Asset>;
    // Number of decimal places used to represent price for all assets quoted by the oracle
    fn decimals() -> u32;
    // Quotes asset price in base asset at specific timestamp
    fn price(caller: Address, asset: Asset, timestamp: u64) -> Option<PriceData>;
    // Quotes the most recent price for an asset
    fn lastprice(caller: Address, asset: Asset) -> Option<PriceData>;
    // Quotes last N price records for the given asset
    fn prices(caller: Address, asset: Asset, records: u32) -> Option<Vec<PriceData>>;
    // Quotes the most recent cross price record for the pair of assets
    fn x_last_price(caller: Address, base_asset: Asset, quote_asset: Asset) -> Option<PriceData>;
    // Quotes the cross price for the pair of assets at specific timestamp
    fn x_price(caller: Address, base_asset: Asset, quote_asset: Asset, timestamp: u64) -> Option<PriceData>;
    // Quotes last N cross price records of for the pair of assets
    fn x_prices(caller: Address, base_asset: Asset, quote_asset: Asset, records: u32) -> Option<Vec<PriceData>>;
    // Quotes the time-weighted average price for the given asset over N recent records
    fn twap(caller: Address, asset: Asset, records: u32) -> Option<i128>;
    // Quotes the time-weighted average cross price for the given asset pair over N recent records
    fn x_twap(caller: Address, base_asset: Asset, quote_asset: Asset, records: u32) -> Option<i128>;
    // Price feed resolution (default tick period timeframe, in seconds - 5 minutes by default)
    fn resolution() -> u32;
    // Historical records retention period, in seconds (24 hours by default)
    fn history_retention_period() -> Option<u64>;
    // The most recent price update timestamp
    fn last_timestamp() -> u64;
    // Contract version
    fn version() -> u32;
    // Contract admin address
    fn admin() -> Option<Address>;
    // Extend asset TTL (time-to-live) in the contract storage
    fn extend_asset_ttl(sponsor: Address, asset: Asset);
    // Get asset expiration timestamp
    fn expires(asset: Asset) -> Option<u64>;
    // Estimate invocation cost based on its complexity
    fn estimate_cost(invocation: InvocationComplexity, periods: u32) -> i128;
}

// Quoted asset definition
#[contracttype(export = false)]
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum Asset {
    Stellar(Address), // for Stellar Classic and Soroban assets
    Other(Symbol)     // for any external currencies/tokens/assets/symbols
}

// Price record definition
#[contracttype(export = false)]
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct PriceData {
    pub price: i128,   // asset price at given point in time
    pub timestamp: u64 // record timestamp
}

// Invocation complexity factor
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum InvocationComplexity {
    NModifier = 0, // multiplier for number of requested periods, not utilized directly for cost calculation
    Price = 1, // single asset price record request
    Twap = 2, // TWAP approximation over N records
    CrossPrice = 3, // cross-price calculation for two assets
    CrossTwap = 4, // TWAP approximation over N records for cross-price quote
}

// Possible runtime errors
#[soroban_sdk::contracterror(export = false)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum Error {
    AlreadyInitialized = 0,
    Unauthorized = 1,
    AssetMissing = 2,
    AssetAlreadyExists = 3,
    InvalidConfigVersion = 4,
    InvalidTimestamp = 5,
    InvalidUpdateLength = 6,
    AssetLimitExceeded = 7,
    InvalidPricesUpdate = 8
}
```

## Development

### Prerequisites

- Ensure you have Rust installed and set up ([official installation guide](https://www.rust-lang.org/tools/install))
- Install Stellar CLI ([CLI installation guide](https://developers.stellar.org/docs/tools/cli/install-cli))

### Compilation

Run `stellar contract build` commands from the project root directory. It will compile all contracts included into the
workspace:

```shell
stellar contract build
```

To compile a specific contract, run `stellar contract build` command with the `--package` argument from the project root
directory:

```shell
stellar contract build --package reflector-pulse-contract
stellar contract build --package reflector-beam-contract
```

#### Optimizing WASM

Use `stellar contract optimize` CLI command to reduce the contract WASM binary size before deployment.
For example:

```shell
stellar contract optimize --wasm ./target/wasm32v1-none/release/reflector_pulse_contract.wasm
```

This command will generate an optimized WASM file at
`./target/wasm32v1-none/release/reflector_pulse_contract.optimized.wasm`.

### Testing

In order to run all workspace tests, execute `cargo test` from the project root directory:

```shell
cargo test
```

Or for a specific contract:

```shell
cargo test --package reflector-pulse-contract
cargo test --package reflector-beam-contract
```
